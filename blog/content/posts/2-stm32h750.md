---
title: "Getting started with STM32H750VB in Rust"
date: 2022-09-17T16:18:56-04:00
draft: true
---

This is the story of my incredibly frustrating start with the STM32H750VB
microcontroller in Rust.

# Online shopping

A few months ago, I was browsing Adafruit and came across a cute looking dev
board called the [WeAct Studio STM32H750 Development Board]. It has

[WeAct Studio STM32H750 Development Board]: https://www.adafruit.com/product/5032

* an LCD screen,
* a camera,
* an SD card slot,
* a USB-C connector, and
* an STM32H750VB microcontroller.

This seemed like a great candidate to get started using embedded rust,
especially because I was hoping to be able to use it as a platform to play
around with [Hubris].

[Hubris]: https://github.com/oxidecomputer/hubris

I ordered it and started messing around.

# Initial commit

I started with cloning the [cortex-m-quickstart] repository on GitHub, a
template that can be used for ARM Cortex M microcontrollers. To begin with, I
looked at the configuration files to see what needed to change:

* `.cargo/config.toml`: The chip that I am using is a Cortex-M4F with an FPU, so
  the target (in `[build]`) should be `thumbv7em-none-eabihf`

* `Cargo.toml`: I added the `stm32h7xx_hal` crate that provides access to
  peripherals in a convenient way.

* `memory.x`: I set up the linker script to just include 128K of flash at
  `0x08000000` and 128K of RAM at `0x2000000`, which corresponds to the DTCM
  RAM. I tried using `0x30000000` for the SRAM1 region, but it didn't work
  :disappointed: **Need to spend more time on this.**

[cortex-m-quickstart]: https://github.com/rust-embedded/cortex-m-quickstart

In my `main.rs`, I started scaffolding the code for blinky:

```rust
#![no_std]
#![no_main]

use panic_halt as _;
use cortex_m_rt::entry;

use stm32h7xx_hal::{
    delay::Delay, pac, prelude::*
};

#[entry]
fn main() -> ! {
    // Init

    loop {

    }
}
```

We have our basic embedded application architecture with an entrypoint
(`[entry]fn main() -> !`), space for initialization code, and a loop.

Let's start filling it in. In our initialization, we need access to the _device_
peripherals like the power configuration and GPIOs:

```rust
let dp = pac::Peripherals::take().unwrap();
```
